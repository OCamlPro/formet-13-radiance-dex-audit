
\chapter{Contract DEXroot}

\minitoc

In file {\tt DEXRoot.sol}

\section{Contract Inheritance}

\noindent\begin{tabular}{|l|p{5cm}|}\hline
IDEXRoot & \\\hline
\end{tabular}

\section{Type Definitions}

\subsection{Struct Pair}

\begin{itemize}
\item Minor Issue: keep naming should be consistent, {\tt root0} and
  {\tt root1}, or {\tt rootA} and {\tt rootB}, but not both. Idem for
  {\tt rootLP} vs {\tt rootAB}.
\end{itemize}

\begin{lstlisting}[firstnumber=24]
	struct Pair {
		address root0;
		address root1;
		address rootLP;
	}
\end{lstlisting}

\section{Constant Definitions}

\begin{lstlisting}[firstnumber=42]
	uint128 constant public GRAMS_CREATE_DEX_CLIENT = 1 ton;
\end{lstlisting}

\section{Static Variable Definitions}

\begin{itemize}
\item Minor Issue: {\tt soUINT} is never used, as in other
  contracts. It would be worth using the same number for all contracts
  derived from this root.
\item \issueStatic{}
\end{itemize}

\begin{lstlisting}[firstnumber=13]
	uint256 static public soUINT;
\end{lstlisting}

\section{Variable Definitions}

\begin{itemize}
\item \issueGlobal{}
\item Minor Issue: naming should be more explicit. For example, {\tt
  roots} could be renamed {\tt pair\_by\_roots}, {\tt pubkeys} amd
  {\tt clients} could be renamed {\tt dexclient\_by\_pubkey} and {\tt
    pubkey\_by\_dexclient}.
\end{itemize}

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
TvmCell & codeDEXclient &  \\\hline
 & & assigned in @4.DEXroot.setDEXclientCode\\\hline
 & & used in @4.DEXroot.setDEXclientCode\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.computeClientAddress\\\hline
TvmCell & codeDEXpair &  \\\hline
 & & assigned in @4.DEXroot.setDEXpairCode\\\hline
 & & used in @4.DEXroot.setDEXpairCode\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.computePairAddress\\\hline
TvmCell & codeDEXconnector &  \\\hline
 & & assigned in @4.DEXroot.setDEXconnectorCode\\\hline
 & & used in @4.DEXroot.setDEXconnectorCode\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.computePairAddress\\\hline
 & & used in @4.DEXroot.computeConnectorAddress\\\hline
 & & used in @4.DEXroot.computeClientAddress\\\hline
TvmCell & codeRootToken &  \\\hline
 & & assigned in @4.DEXroot.setRootTokenCode\\\hline
 & & used in @4.DEXroot.setRootTokenCode\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.computeRootTokenAddress\\\hline
TvmCell & codeTONTokenWallet &  \\\hline
 & & assigned in @4.DEXroot.setTONTokenWalletCode\\\hline
 & & used in @4.DEXroot.setTONTokenWalletCode\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.computeRootTokenAddress\\\hline
mapping (address =$>$ mapping (address =$>$ address)) & roots &  \\\hline
 & & used in @4.DEXroot.getPairByRoots10\\\hline
 & & used in @4.DEXroot.getPairByRoots01\\\hline
 & & assigned in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & assigned in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
mapping (address =$>$ Pair) & pairs &  \\\hline
 & & used in @4.DEXroot.getRootsByPair\\\hline
 & & assigned in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
address [] & pairKeys &  \\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
mapping (uint256 =$>$ address) & pubkeys &  \\\hline
 & & assigned in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.checkPubKey\\\hline
 & & used in @4.DEXroot.checkPubKey\\\hline
mapping (address =$>$ uint256) & clients &  \\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & used in @4.DEXroot.createDEXpair\\\hline
 & & assigned in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
address [] & clientKeys &  \\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
mapping (address =$>$ uint128) & balanceOf &  \\\hline
 & & assigned in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & assigned in @4.DEXroot.:receive\\\hline
 & & used in @4.DEXroot.:receive\\\hline
mapping (uint256 =$>$ address) & creators &  \\\hline
 & & assigned in @4.DEXroot.setCreator\\\hline
 & & used in @4.DEXroot.setCreator\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
 & & used in @4.DEXroot.createDEXclient\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=15]
	TvmCell public codeDEXclient;
\end{lstlisting}

\begin{lstlisting}[firstnumber=16]
	TvmCell public codeDEXpair;
\end{lstlisting}

\begin{lstlisting}[firstnumber=17]
	TvmCell public codeDEXconnector;
\end{lstlisting}

\begin{lstlisting}[firstnumber=18]
	TvmCell public codeRootToken;
\end{lstlisting}

\begin{lstlisting}[firstnumber=19]
	TvmCell public codeTONTokenWallet;
\end{lstlisting}

\begin{lstlisting}[firstnumber=21]
	mapping(address => mapping(address => address)) roots;
\end{lstlisting}

\begin{lstlisting}[firstnumber=30]
	mapping(address => Pair) public pairs;
\end{lstlisting}

\begin{lstlisting}[firstnumber=31]
	address[] public pairKeys;
\end{lstlisting}

\begin{lstlisting}[firstnumber=33]
	mapping(uint256 => address) public pubkeys;
\end{lstlisting}

\begin{lstlisting}[firstnumber=34]
	mapping(address => uint256) public clients;
\end{lstlisting}

\begin{lstlisting}[firstnumber=35]
	address[] public clientKeys;
\end{lstlisting}

\begin{lstlisting}[firstnumber=37]
	mapping(address => uint128) public balanceOf;
\end{lstlisting}

\begin{lstlisting}[firstnumber=38]
	mapping(uint256 => address) public creators;
\end{lstlisting}

\section{Modifier Definitions}

\subsection{Modifier alwaysAccept}

\begin{itemize}
\item \issueAlwaysAccept{DEXroot}
\end{itemize}

\begin{lstlisting}[firstnumber=45]
	modifier alwaysAccept {
		tvm.accept();
		_;
	}
\end{lstlisting}

\subsection{Modifier checkOwnerAndAccept}

\begin{itemize}
\item \issueError{}
\end{itemize}

\begin{lstlisting}[firstnumber=51]
	modifier checkOwnerAndAccept {
		require(msg.pubkey() == tvm.pubkey(), 101);
		tvm.accept();
		_;
	}
\end{lstlisting}

\subsection{Modifier checkCreatorAndAccept}

\begin{itemize}
\item \issueCritical{Accept-All Modifier in {\tt DEXroot}}{See Accept
  Methods withtout Checks (\ref{accept:all}). The check on pubkey
  performed by this modifier is too weak to limit {\tt tvm.accept}.}
\item \issueError{}
\end{itemize}

\begin{lstlisting}[firstnumber=58]
	modifier checkCreatorAndAccept {
		require(msg.pubkey() != 0, 103);
		tvm.accept();
		_;
	}
\end{lstlisting}

\section{Constructor Definitions}

\subsection{Constructor}

\begin{itemize}
\item \issueNumber{}
\end{itemize}

\begin{lstlisting}[firstnumber=65]
	constructor() public {
		require(tvm.pubkey() == msg.pubkey(), 102);
		tvm.accept();
	}
\end{lstlisting}

\section{Public Method Definitions}

\subsection{Receive function}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=76]
	receive() external {
		balanceOf[msg.sender] += msg.value;
	}
\end{lstlisting}

\subsection{Function checkPubKey}

\begin{itemize}
\item \issueAccept{DEXroot.checkPubKey}{The balance of the contract
  could be drained by sending many {\tt checkPubKey} messages. This
  method could be a get-method without {\tt tvm.accept}, to be
  executed locally.}
\end{itemize}

\begin{lstlisting}[firstnumber=328]
	function checkPubKey(uint256 pubkey) public view alwaysAccept returns (bool status, address dexclient) {
		status = pubkeys.exists(pubkey);
		dexclient = pubkeys[pubkey];
	}
\end{lstlisting}

\subsection{Function createDEXclient}

\begin{itemize}
\item \issueAccept{DEXroot.createDEXclient}{
  \begin{itemize}
  \item The balance of the contract could be drained, by sending many
    unexpected {\tt createDEXclient} messages by an attacker.
  \item The balance could be further drained by the {\tt require()}
    failing after {\tt tvm.accept}, causing replication on all shards.
  \end{itemize}
}
\item Minor Issue: the method should check for correct initialization
  of the {\tt codeDEXclient}, for example by using a bitmap set by all
  {\tt setDEX*code} methods.
\item \issueUnits{}. Use {\tt 0.0031 ton} instead of {\tt 3100000}.
\item \issueError{}
\end{itemize}

\begin{lstlisting}[firstnumber=122]
	function createDEXclient(uint256 pubkey, uint256 souint) public alwaysAccept returns (address deployedAddress, bool statusCreate){
		statusCreate = false;
		deployedAddress = address(0);
		uint128 prepay = balanceOf[creators[pubkey]];
		require (!pubkeys.exists(pubkey) && !(prepay < GRAMS_CREATE_DEX_CLIENT), 106);
		delete balanceOf[creators[pubkey]];
		TvmCell stateInit = tvm.buildStateInit({
			contr: DEXClient,
			varInit: {rootDEX:address(this),soUINT:souint,codeDEXConnector:codeDEXconnector},
			code: codeDEXclient,
			pubkey: pubkey
		});
		deployedAddress = new DEXClient{
			stateInit: stateInit,
			flag: 0,
			bounce : false,
			value : (prepay - 3100000)
		}();
		pubkeys[pubkey] = deployedAddress;
		clients[deployedAddress] = pubkey;
		clientKeys.push(deployedAddress);
		statusCreate = true;
	}
\end{lstlisting}

\subsection{Function createDEXpair}

\begin{itemize}
\item \issueCritical{Ownership of Liquidity Root Contract}{This method
  allows ANY {\tt DEXClient} to generate any non-existent {\tt
    DEXPair}, including its liquidity root contract, passing all the
  static attributes, such as {\tt name}, {\tt symbol}, {\tt decimals}
  and the {\tt \_randomNonce}, as arguments of the call. An attacker
  could use this possibility to take ownership of the liquidity root
  contract: the attacker would deploy that contract before the call to
  {\tt createDEXpair}, but with constructor arguments giving him
  ownership of the contract; then, during the call to {\tt
    createDEXpair}, the deployment would fail, but the contract would
  not notice it, and the pair would be created with the attacker-owned
  liquidity root contract. The fix would be to define the owner of the
  contract as a static variable in {\tt RootTokenContract}. }
\item Minor Issue: the method should check for correct initialization
  of the {\tt codeDEXpair} and {\tt codeRootToken}, for example by
  using a bitmap set by all {\tt setDEX*code} methods.
\item \issueError{}
\item \issueUnits{}
\end{itemize}

\begin{lstlisting}[firstnumber=237]
	function createDEXpair(
		address root0,
		address root1,
		uint256 pairSoArg,
		uint256 connectorSoArg0,
		uint256 connectorSoArg1,
		uint256 rootSoArg,
		bytes rootName,
		bytes rootSymbol,
		uint8 rootDecimals,
		uint128 grammsForPair,
		uint128 grammsForRoot,
		uint128 grammsForConnector,
		uint128 grammsForWallet
	) public override {
		require(root0 != address(0) && root1 != address(0) ,104);
		require(!(grammsForPair < 500000000) && !(grammsForRoot < 500000000) && !(grammsForConnector < 500000000) && !(grammsForWallet < 500000000),105);
		tvm.rawReserve(address(this).balance - msg.value, 2);
		uint128 grammsNeeded = grammsForPair + (2 * grammsForConnector) + (2 * grammsForWallet) + grammsForRoot;
		if (clients.exists(msg.sender) && !(msg.value < grammsNeeded) && !(root0 == root1) && !roots[root0].exists(root1) && !roots[root1].exists(root0)) {
			TvmCell stateInitR = tvm.buildStateInit({
				contr: RootTokenContract,
				varInit: {
					_randomNonce:rootSoArg,
					name:rootName,
					symbol:rootSymbol,
					decimals:rootDecimals,
					wallet_code:codeTONTokenWallet
				},
				code: codeRootToken,
				pubkey : clients[msg.sender]
			});
			address root01 = address(tvm.hash(stateInitR));
			TvmCell stateInitP = tvm.buildStateInit({
				contr: DEXPair,
				varInit: {
					rootDEX:address(this),
					soUINT:pairSoArg,
					creator:msg.sender,
					codeDEXConnector:codeDEXconnector,
					rootA:root0,
					rootB:root1,
					rootAB:root01
				},
				code: codeDEXpair,
				pubkey : clients[msg.sender]
			});
			address pairAddress = new DEXPair{
				stateInit: stateInitP,
				flag: 0,
				bounce : false,
				value : grammsForPair + (2 * grammsForConnector) + (2 * grammsForWallet)
			}(connectorSoArg0, connectorSoArg1, grammsForConnector, grammsForWallet);
			address rootAddress = new RootTokenContract{
				stateInit: stateInitR,
				flag: 0,
				bounce : false,
				value : grammsForRoot
			}(0, pairAddress);
			roots[root0][root1] = pairAddress;
			roots[root1][root0] = pairAddress;
			Pair cp = pairs[pairAddress];
			cp.root0 = root0;
			cp.root1 = root1;
			cp.rootLP = rootAddress;
			pairs[pairAddress] = cp;
			pairKeys.push(pairAddress);
			msg.sender.transfer({ value: 0, flag: 128});
		} else {
			msg.sender.transfer({ value: 0, flag: 128});
		}
	}
\end{lstlisting}

\subsection{Function getBalanceTONgrams}

\begin{itemize}
\item \issueAccept{DEXroot.getBalanceTONgrams}{The balance of the contract
  could be drained by sending many {\tt getBalanceTONgrams} messages. This
  method could be a get-method without {\tt tvm.accept}, to be
  executed locally.}
\end{itemize}

\begin{lstlisting}[firstnumber=334]
	function getBalanceTONgrams() public pure alwaysAccept returns (uint128 balanceTONgrams){
		return address(this).balance;
	}
\end{lstlisting}

\subsection{Function getClientAddress}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=118]
	function getClientAddress(uint256 clientPubKey, uint256 clientSoArg) public view responsible returns (address) {
		return { value: 0, bounce: false, flag: 64 } computeClientAddress(clientPubKey,clientSoArg);
	}
\end{lstlisting}

\subsection{Function getConnectorAddress}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=233]
	function getConnectorAddress(uint256 connectorPubKey, uint256 connectorSoArg, address connectorCommander) public view responsible returns (address) {
		return { value: 0, bounce: false, flag: 64 } computeConnectorAddress(connectorPubKey, connectorSoArg, connectorCommander);
	}
\end{lstlisting}

\subsection{Function getPairAddress}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=171]
	function getPairAddress(
		uint256 pairPubKey,
		uint256 pairSoArg,
		address pairCreator,
		address pairRootA,
		address pairRootB,
		address pairRootAB
	) public view responsible returns (address) {
		return { value: 0, bounce: false, flag: 64 } computePairAddress(pairPubKey,pairSoArg,pairCreator,pairRootA,pairRootB,pairRootAB);
	}
\end{lstlisting}

\subsection{Function getPairByRoots01}

\begin{itemize}
\item \issueAccept{DEXroot.getPairByRoots01}{The balance of the contract
  could be drained by sending many {\tt getPairByRoots01} messages. This
  method could be a get-method without {\tt tvm.accept}, to be
  executed locally.}
\end{itemize}

\begin{lstlisting}[firstnumber=314]
	function getPairByRoots01(address root0, address root1) public view alwaysAccept returns (address pairAddr) {
		pairAddr = roots[root0][root1];
	}
\end{lstlisting}

\subsection{Function getPairByRoots10}

\begin{itemize}
\item \issueAccept{DEXroot.getPairByRoots10}{The balance of the contract
  could be drained by sending many {\tt getPairByRoots10} messages. This
  method could be a get-method without {\tt tvm.accept}, to be
  executed locally.}
\end{itemize}

\begin{lstlisting}[firstnumber=318]
	function getPairByRoots10(address root1, address root0) public view alwaysAccept returns (address pairAddr) {
		pairAddr = roots[root1][root0];
	}
\end{lstlisting}

\subsection{Function getRootTokenAddress}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=213]
	function getRootTokenAddress(
		uint256 rootPubKey,
		uint256 rootSoArg,
		bytes rootName,
		bytes rootSymbol,
		uint8 rootDecimals
	) public view responsible returns (address) {
		return { value: 0, bounce: false, flag: 64 } computeRootTokenAddress(rootPubKey,rootSoArg,rootName,rootSymbol,rootDecimals);
	}
\end{lstlisting}

\subsection{Function getRootsByPair}

\begin{itemize}
\item \issueAccept{DEXroot.getRootsByPair}{The balance of the contract
  could be drained by sending many {\tt getRootsByPair} messages. This
  method could be a get-method without {\tt tvm.accept}, to be
  executed locally.}
\end{itemize}

\begin{lstlisting}[firstnumber=322]
	function getRootsByPair(address pairAddr) public view alwaysAccept returns (address root0, address root1) {
		Pair cp = pairs[pairAddr];
		root0 = cp.root0;
		root1 = cp.root1;
	}
\end{lstlisting}

\subsection{Function sendTransfer}

\begin{itemize}
\item OK
\end{itemize}

\begin{lstlisting}[firstnumber=71]
	function sendTransfer(address dest, uint128 value, bool bounce) public pure checkOwnerAndAccept {
		dest.transfer(value, bounce, 0);
	}
\end{lstlisting}

\subsection{Function setCreator}

\begin{itemize}
\item \issueCritical{Impersonate Accounts in {\tt
    DEXroot.setCreator}}{Anybody can impersonate himself as the owner
  of any {\tt giverAddr}. Later, in {\tt createDEXclient}, ownership
  of {\tt giverAddr} can be used to spend the corresponding {\tt
    balanceOf} to create a {\tt DEXClient} using somebody else's
  funds.}
\end{itemize}

\begin{lstlisting}[firstnumber=100]
	function setCreator(address giverAddr) public checkCreatorAndAccept {
		uint256 pubkey = msg.pubkey();
		creators[pubkey] = giverAddr;
	}
\end{lstlisting}

\subsection{Function setDEXclientCode}

\begin{itemize}
\item Minor Issue: the code should be checked against a code hash,
  hardcoded in the code, or set either in the constructor or in the
  static variables.
\item Minor Issue: a bitmap should be used to verify that the contract
  has been properly initialized, i.e. all the codes of the
  sub-contracts have been correctly set.
\end{itemize}

\begin{lstlisting}[firstnumber=80]
	function setDEXclientCode(TvmCell code) public checkOwnerAndAccept {
		codeDEXclient = code;
	}
\end{lstlisting}

\subsection{Function setDEXconnectorCode}


\begin{itemize}
\item Minor Issue: the code should be checked against a code hash,
  hardcoded in the code, or set either in the constructor or in the
  static variables.
\item Minor Issue: a bitmap should be used to verify that the contract
  has been properly initialized, i.e. all the codes of the
  sub-contracts have been correctly set.
\end{itemize}

\begin{lstlisting}[firstnumber=88]
	function setDEXconnectorCode(TvmCell code) public checkOwnerAndAccept {
		codeDEXconnector = code;
	}
\end{lstlisting}

\subsection{Function setDEXpairCode}

\begin{itemize}
\item Minor Issue: the code should be checked against a code hash,
  hardcoded in the code, or set either in the constructor or in the
  static variables.
\item Minor Issue: a bitmap should be used to verify that the contract
  has been properly initialized, i.e. all the codes of the
  sub-contracts have been correctly set.
\end{itemize}

\begin{lstlisting}[firstnumber=84]
	function setDEXpairCode(TvmCell code) public checkOwnerAndAccept {
		codeDEXpair = code;
	}
\end{lstlisting}

\subsection{Function setRootTokenCode}

\begin{itemize}
\item Minor Issue: the code should be checked against a code hash,
  hardcoded in the code, or set either in the constructor or in the
  static variables.
\item Minor Issue: a bitmap should be used to verify that the contract
  has been properly initialized, i.e. all the codes of the
  sub-contracts have been correctly set.
\end{itemize}

\begin{lstlisting}[firstnumber=92]
	function setRootTokenCode(TvmCell code) public checkOwnerAndAccept {
		codeRootToken = code;
	}
\end{lstlisting}

\subsection{Function setTONTokenWalletCode}

\begin{itemize}
\item Minor Issue: the code should be checked against a code hash,
  hardcoded in the code, or set either in the constructor or in the
  static variables.
\item Minor Issue: a bitmap should be used to verify that the contract
  has been properly initialized, i.e. all the codes of the
  sub-contracts have been correctly set.
\end{itemize}

\begin{lstlisting}[firstnumber=96]
	function setTONTokenWalletCode(TvmCell code) public checkOwnerAndAccept {
		codeTONTokenWallet = code;
	}
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function computeClientAddress}

\begin{itemize}
\item Minor Issue: Repeated Code. All the {\tt tvm.buildStateInit}
  calls for various contracts could be put in internal functions, used
  by both deployment methods and compute-address methods.
\item \issueInternal
\end{itemize}

\begin{lstlisting}[firstnumber=108]
	function computeClientAddress(uint256 pubkey, uint256 souint) private inline view returns (address) {
		TvmCell stateInit = tvm.buildStateInit({
			contr: DEXClient,
			varInit: {rootDEX:address(this),soUINT:souint,codeDEXConnector:codeDEXconnector},
			code: codeDEXclient,
			pubkey: pubkey
		});
		return address(tvm.hash(stateInit));
	}
\end{lstlisting}

\subsection{Function computeConnectorAddress}

\begin{itemize}
\item \issueInternal
\end{itemize}

\begin{lstlisting}[firstnumber=223]
	function computeConnectorAddress(uint256 pubkey, uint256 souint, address commander) private inline view returns (address) {
		TvmCell stateInit = tvm.buildStateInit({
			contr: DEXConnector,
			varInit: { soUINT: souint, dexclient: commander },
			code: codeDEXconnector,
			pubkey: pubkey
		});
		return address(tvm.hash(stateInit));
	}
\end{lstlisting}

\subsection{Function computePairAddress}

\begin{itemize}
\item \issueInternal
\end{itemize}

\begin{lstlisting}[firstnumber=146]
	function computePairAddress(
		uint256 pubkey,
		uint256 souint,
		address creator,
		address rootA,
		address rootB,
		address rootAB
	) private inline view returns (address){
		TvmCell stateInit = tvm.buildStateInit({
			contr: DEXPair,
			varInit: {
				rootDEX:address(this),
				soUINT:souint,
				creator:creator,
				codeDEXConnector:codeDEXconnector,
				rootA:rootA,
				rootB:rootB,
				rootAB:rootAB
			},
			code: codeDEXpair,
			pubkey : pubkey
		});
		return address(tvm.hash(stateInit));
	}
\end{lstlisting}

\subsection{Function computeRootTokenAddress}

\begin{itemize}
\item \issueInternal
\end{itemize}

\begin{lstlisting}[firstnumber=182]
	function computeRootTokenAddress(
		uint256 pubkey,
		uint256 souint,
		bytes name,
		bytes symbol,
		uint8 decimals
	) private inline view returns (address){
		TvmCell stateInit = tvm.buildStateInit({
			contr: RootTokenContract,
			varInit: {
				_randomNonce:souint,
				name:name,
				symbol:symbol,
				decimals:decimals,
				wallet_code:codeTONTokenWallet
			},
			code: codeRootToken,
			pubkey : pubkey
		});
		return address(tvm.hash(stateInit));
	}
\end{lstlisting}
