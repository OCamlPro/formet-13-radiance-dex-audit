
\chapter{Contract RootTokenContract}


In file {\tt RootTokenContract.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
IRootTokenContract & \\\hline
IBurnableTokenRootContract & \\\hline
IBurnableByRootTokenRootContract & \\\hline
IPausable & \\\hline
ITransferOwner & \\\hline
ISendSurplusGas & \\\hline
IVersioned & \\\hline
\end{tabular}


\section{Static Variable Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Use a naming convention to distinguish static variables from global variables, such as \verb+s_+ prefix.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
uint256 & \_{}randomNonce &  \\\hline
bytes & name &  \\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
bytes & symbol &  \\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
uint8 & decimals &  \\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
TvmCell & wallet\_{}code &  \\\hline
 & & used in @5.RootTokenContract.getWalletCode\\\hline
 & & used in @5.RootTokenContract.getExpectedWalletAddress\\\hline
 & & used in @5.RootTokenContract.getExpectedWalletAddress\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & used in @5.RootTokenContract.deployEmptyWallet\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=28]
    uint256 static _randomNonce;
\end{lstlisting}

\begin{lstlisting}[firstnumber=30]
    bytes public static name;
\end{lstlisting}

\begin{lstlisting}[firstnumber=31]
    bytes public static symbol;
\end{lstlisting}

\begin{lstlisting}[firstnumber=32]
    uint8 public static decimals;
\end{lstlisting}

\begin{lstlisting}[firstnumber=34]
    TvmCell static wallet_code;
\end{lstlisting}

\section{Variable Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Use a naming convention to distinguish global variables from local variables, such as \verb+g_+ or \verb+m_+ prefix.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
uint128 & total\_{}supply &  \\\hline
 & & assigned in @5.RootTokenContract.tokensBurned\\\hline
 & & used in @5.RootTokenContract.tokensBurned\\\hline
 & & assigned in @5.RootTokenContract.mint\\\hline
 & & used in @5.RootTokenContract.mint\\\hline
 & & used in @5.RootTokenContract.getTotalSupply\\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
 & & assigned in @5.RootTokenContract.deployWallet\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & assigned in @5.RootTokenContract.:onBounce\\\hline
 & & used in @5.RootTokenContract.:onBounce\\\hline
 & & assigned in @5.RootTokenContract.:constructor\\\hline
 & & used in @5.RootTokenContract.:constructor\\\hline
uint256 & root\_{}public\_{}key &  \\\hline
 & & assigned in @5.RootTokenContract.transferOwner\\\hline
 & & used in @5.RootTokenContract.transferOwner\\\hline
 & & used in @5.RootTokenContract.isExternalOwner\\\hline
 & & used in @5.RootTokenContract.isExternalOwner\\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
 & & assigned in @5.RootTokenContract.:constructor\\\hline
 & & used in @5.RootTokenContract.:constructor\\\hline
address & root\_{}owner\_{}address &  \\\hline
 & & assigned in @5.RootTokenContract.transferOwner\\\hline
 & & used in @5.RootTokenContract.transferOwner\\\hline
 & & used in @5.RootTokenContract.isInternalOwner\\\hline
 & & used in @5.RootTokenContract.isInternalOwner\\\hline
 & & used in @5.RootTokenContract.getDetails\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & assigned in @5.RootTokenContract.:constructor\\\hline
 & & used in @5.RootTokenContract.:constructor\\\hline
uint128 & start\_{}gas\_{}balance &  \\\hline
 & & used in @5.RootTokenContract.sendSurplusGas\\\hline
 & & used in @5.RootTokenContract.deployWallet\\\hline
 & & assigned in @5.RootTokenContract.:constructor\\\hline
 & & used in @5.RootTokenContract.:constructor\\\hline
bool & paused &  \\\hline
 & & used in @5.RootTokenContract.tokensBurned\\\hline
 & & assigned in @5.RootTokenContract.setPaused\\\hline
 & & used in @5.RootTokenContract.setPaused\\\hline
 & & used in @5.RootTokenContract.sendPausedCallbackTo\\\hline
 & & assigned in @5.RootTokenContract.:constructor\\\hline
 & & used in @5.RootTokenContract.:constructor\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=36]
    uint128 total_supply;
\end{lstlisting}

\begin{lstlisting}[firstnumber=38]
    uint256 root_public_key;
\end{lstlisting}

\begin{lstlisting}[firstnumber=39]
    address root_owner_address;
\end{lstlisting}

\begin{lstlisting}[firstnumber=40]
    uint128 public start_gas_balance;
\end{lstlisting}

\begin{lstlisting}[firstnumber=42]
    bool public paused;
\end{lstlisting}

\section{Modifier Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Calling tvm.accept() without checking pubkey should not be allowed
\\\hline\end{tabular}
\fi

\subsection{Modifier onlyOwner}


\begin{lstlisting}[firstnumber=458]
    modifier onlyOwner() {
        require(isOwner(), RootTokenContractErrors.error_message_sender_is_not_my_owner);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyInternalOwner}


\begin{lstlisting}[firstnumber=463]
    modifier onlyInternalOwner() {
        require(isInternalOwner(), RootTokenContractErrors.error_message_sender_is_not_my_owner);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Check who can call the constructor. If the constructor sets global values, only legitimate users should be allowed.
\\\hline
Check that every argument is protected by a require().
\\\hline
If external users are allowed, their pubkey should be verified (\verb+require(msg.pubkey() != 0 && msg.pubkey() == tvm.pubkey(),100)+ , and tvm.accept() should be called.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt root\_{}public\_{}key\_{} &\\\hline
\tt address & \tt root\_{}owner\_{}address\_{} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=48]
    constructor(uint256 root_public_key_, address root_owner_address_) public {
        require((root_public_key_ != 0 && root_owner_address_.value == 0) ||
                (root_public_key_ == 0 && root_owner_address_.value != 0),
                RootTokenContractErrors.error_define_public_key_or_owner_address);
        tvm.accept();

        root_public_key = root_public_key_;
        root_owner_address = root_owner_address_;

        total_supply = 0;
        paused = false;

        start_gas_balance = address(this).balance;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Fallback function}

\vspace{2cm}

\begin{lstlisting}[firstnumber=523]
    fallback() external {
    }
\end{lstlisting}

\subsection{OnBounce function}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt TvmSlice & \tt slice &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=514]
    onBounce(TvmSlice slice) external {
        tvm.accept();
        uint32 functionId = slice.decode(uint32);
        if (functionId == tvm.functionId(ITONTokenWallet.accept)) {
            uint128 latest_bounced_tokens = slice.decode(uint128);
            total_supply -= latest_bounced_tokens;
        }
    }
\end{lstlisting}

\subsection{Function deployEmptyWallet}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt deploy\_{}grams &\\\hline
\tt uint256 & \tt wallet\_{}public\_{}key\_{} &\\\hline
\tt address & \tt owner\_{}address\_{} &\\\hline
\tt address & \tt gas\_{}back\_{}address &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=237]
    function deployEmptyWallet(
        uint128 deploy_grams,
        uint256 wallet_public_key_,
        address owner_address_,
        address gas_back_address
    )
        override
        external
    returns (
        address
    ) {
        require((owner_address_.value != 0 && wallet_public_key_ == 0) ||
                (owner_address_.value == 0 && wallet_public_key_ != 0),
                RootTokenContractErrors.error_define_public_key_or_owner_address);

        tvm.rawReserve(address(this).balance - msg.value, 2);

        address wallet = new TONTokenWallet{
            value: deploy_grams,
            flag: 1,
            code: wallet_code,
            pubkey: wallet_public_key_,
            varInit: {
                root_address: address(this),
                code: wallet_code,
                wallet_public_key: wallet_public_key_,
                owner_address: owner_address_
            }
        }();

        if (gas_back_address.value != 0) {
            gas_back_address.transfer({ value: 0, flag: 128 });
        } else {
            msg.sender.transfer({ value: 0, flag: 128 });
        }

        return wallet;
    }
\end{lstlisting}

\subsection{Function deployWallet}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt tokens &\\\hline
\tt uint128 & \tt deploy\_{}grams &\\\hline
\tt uint256 & \tt wallet\_{}public\_{}key\_{} &\\\hline
\tt address & \tt owner\_{}address\_{} &\\\hline
\tt address & \tt gas\_{}back\_{}address &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=164]
    function deployWallet(
        uint128 tokens,
        uint128 deploy_grams,
        uint256 wallet_public_key_,
        address owner_address_,
        address gas_back_address
    )
        override
        external
        onlyOwner
    returns(
        address
    ) {
        require(tokens >= 0);
        require((owner_address_.value != 0 && wallet_public_key_ == 0) ||
                (owner_address_.value == 0 && wallet_public_key_ != 0),
                RootTokenContractErrors.error_define_public_key_or_owner_address);

        if(root_owner_address.value == 0) {
            tvm.accept();
        } else {
            tvm.rawReserve(math.max(start_gas_balance, address(this).balance - msg.value), 2);
        }

        TvmCell stateInit = tvm.buildStateInit({
            contr: TONTokenWallet,
            varInit: {
                root_address: address(this),
                code: wallet_code,
                wallet_public_key: wallet_public_key_,
                owner_address: owner_address_
            },
            pubkey: wallet_public_key_,
            code: wallet_code
        });

        address wallet;

        if(deploy_grams > 0) {
            wallet = new TONTokenWallet{
                stateInit: stateInit,
                value: deploy_grams,
                wid: address(this).wid,
                flag: 1
            }();
        } else {
            wallet = address(tvm.hash(stateInit));
        }

        ITONTokenWallet(wallet).accept(tokens);

        total_supply += tokens;

        if (root_owner_address.value != 0) {
            if (gas_back_address.value != 0) {
                gas_back_address.transfer({ value: 0, flag: 128 });
            } else {
                msg.sender.transfer({ value: 0, flag: 128 });
            }
        }

        return wallet;
    }
\end{lstlisting}

\subsection{Function getDetails}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt IRootTokenContractDetails & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=77]
    function getDetails() override external view responsible returns (IRootTokenContractDetails) {
        return { value: 0, bounce: false, flag: 64 } IRootTokenContractDetails(
            name,
            symbol,
            decimals,
            root_public_key,
            root_owner_address,
            total_supply
        );
    }
\end{lstlisting}

\subsection{Function getTotalSupply}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint128 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=92]
    function getTotalSupply() override external view responsible returns (uint128) {
        return { value: 0, bounce: false, flag: 64 } total_supply;
    }
\end{lstlisting}

\subsection{Function getVersion}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint32 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=63]
    function getVersion() override external pure responsible returns (uint32) {
        return 4;
    }
\end{lstlisting}

\subsection{Function getWalletAddress}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt wallet\_{}public\_{}key\_{} &\\\hline
\tt address & \tt owner\_{}address\_{} &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=111]
    function getWalletAddress(
        uint256 wallet_public_key_,
        address owner_address_
    )
        override
        external
        view
        responsible
    returns (
        address
    ) {
        require((owner_address_.value != 0 && wallet_public_key_ == 0) ||
                (owner_address_.value == 0 && wallet_public_key_ != 0),
                RootTokenContractErrors.error_define_public_key_or_owner_address);
        return { value: 0, bounce: false, flag: 64 } getExpectedWalletAddress(wallet_public_key_, owner_address_);
    }
\end{lstlisting}

\subsection{Function getWalletCode}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt TvmCell & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=100]
    function getWalletCode() override external view responsible returns (TvmCell) {
        return { value: 0, bounce: false, flag: 64 } wallet_code;
    }
\end{lstlisting}

\subsection{Function mint}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt tokens &\\\hline
\tt address & \tt to &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=282]
    function mint(
        uint128 tokens,
        address to
    )
        override
        external
        onlyOwner
    {
        tvm.accept();

        ITONTokenWallet(to).accept(tokens);

        total_supply += tokens;
    }
\end{lstlisting}

\subsection{Function proxyBurn}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt tokens &\\\hline
\tt address & \tt sender\_{}address &\\\hline
\tt address & \tt send\_{}gas\_{}to &\\\hline
\tt address & \tt callback\_{}address &\\\hline
\tt TvmCell & \tt callback\_{}payload &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyInternalOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=307]
    function proxyBurn(
        uint128 tokens,
        address sender_address,
        address send_gas_to,
        address callback_address,
        TvmCell callback_payload
    )
        override
        external
        onlyInternalOwner
    {
        tvm.rawReserve(address(this).balance - msg.value, 2);

        address send_gas_to_ = send_gas_to;
        address expectedWalletAddress = getExpectedWalletAddress(0, sender_address);

        if (send_gas_to.value == 0) {
            send_gas_to_ = sender_address;
        }

        IBurnableByRootTokenWallet(expectedWalletAddress).burnByRoot{value: 0, flag: 128}(
            tokens,
            send_gas_to_,
            callback_address,
            callback_payload
        );
    }
\end{lstlisting}

\subsection{Function sendExpectedWalletAddress}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt wallet\_{}public\_{}key\_{} &\\\hline
\tt address & \tt owner\_{}address\_{} &\\\hline
\tt address & \tt to &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=134]
    function sendExpectedWalletAddress(
        uint256 wallet_public_key_,
        address owner_address_,
        address to
    )
        override
        external
    {
        tvm.rawReserve(address(this).balance - msg.value, 2);

        address wallet = getExpectedWalletAddress(wallet_public_key_, owner_address_);
        IExpectedWalletAddressCallback(to).expectedWalletAddressCallback{value: 0, flag: 128}(
            wallet,
            wallet_public_key_,
            owner_address_
        );
    }
\end{lstlisting}

\subsection{Function sendPausedCallbackTo}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint64 & \tt callback\_{}id &\\\hline
\tt address & \tt callback\_{}addr &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=423]
    function sendPausedCallbackTo(
        uint64 callback_id,
        address callback_addr
    )
        override
        external
    {
        tvm.rawReserve(address(this).balance - msg.value, 2);
        IPausedCallback(callback_addr).pausedCallback{ value: 0, flag: 128 }(callback_id, paused);
    }
\end{lstlisting}

\subsection{Function sendSurplusGas}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt to &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyInternalOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=386]
    function sendSurplusGas(
        address to
    )
        override
        external
        onlyInternalOwner
    {
        tvm.rawReserve(start_gas_balance, 2);
        IReceiveSurplusGas(to).receiveSurplusGas{ value: 0, flag: 128 }();
    }
\end{lstlisting}

\subsection{Function setPaused}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt bool & \tt value &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=407]
    function setPaused(
        bool value
    )
        override
        external
        onlyOwner
    {
        tvm.accept();
        paused = value;
    }
\end{lstlisting}

\subsection{Function tokensBurned}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt tokens &\\\hline
\tt uint256 & \tt sender\_{}public\_{}key &\\\hline
\tt address & \tt sender\_{}address &\\\hline
\tt address & \tt send\_{}gas\_{}to &\\\hline
\tt address & \tt callback\_{}address &\\\hline
\tt TvmCell & \tt callback\_{}payload &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=347]
    function tokensBurned(
        uint128 tokens,
        uint256 sender_public_key,
        address sender_address,
        address send_gas_to,
        address callback_address,
        TvmCell callback_payload
    ) override external {

        require(!paused, RootTokenContractErrors.error_paused);

        address expectedWalletAddress = getExpectedWalletAddress(sender_public_key, sender_address);

        require(msg.sender == expectedWalletAddress, RootTokenContractErrors.error_message_sender_is_not_good_wallet);

        tvm.rawReserve(address(this).balance - msg.value, 2);

        total_supply -= tokens;

        if (callback_address.value == 0) {
            send_gas_to.transfer({ value: 0, flag: 128 });
        } else {
            IBurnTokensCallback(callback_address).burnCallback{value: 0, flag: 128}(
                tokens,
                callback_payload,
                sender_public_key,
                sender_address,
                expectedWalletAddress,
                send_gas_to
            );
        }

    }
\end{lstlisting}

\subsection{Function transferOwner}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt root\_{}public\_{}key\_{} &\\\hline
\tt address & \tt root\_{}owner\_{}address\_{} &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt onlyOwner & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=440]
    function transferOwner(
        uint256 root_public_key_,
        address root_owner_address_
    )
        override
        external
        onlyOwner
    {
        require((root_public_key_ != 0 && root_owner_address_.value == 0) ||
                (root_public_key_ == 0 && root_owner_address_.value != 0),
                RootTokenContractErrors.error_define_public_key_or_owner_address);
        tvm.accept();
        root_public_key = root_public_key_;
        root_owner_address = root_owner_address_;
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function getExpectedWalletAddress}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt wallet\_{}public\_{}key\_{} &\\\hline
\tt address & \tt owner\_{}address\_{} &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=485]
    function getExpectedWalletAddress(
        uint256 wallet_public_key_,
        address owner_address_
    )
        private
        inline
        view
    returns (
        address
    ) {
        TvmCell stateInit = tvm.buildStateInit({
            contr: TONTokenWallet,
            varInit: {
                root_address: address(this),
                code: wallet_code,
                wallet_public_key: wallet_public_key_,
                owner_address: owner_address_
            },
            pubkey: wallet_public_key_,
            code: wallet_code
        });

        return address(tvm.hash(stateInit));
    }
\end{lstlisting}

\subsection{Function isExternalOwner}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=476]
    function isExternalOwner() private inline view returns (bool) {
        return root_public_key != 0 && root_public_key == msg.pubkey();
    }
\end{lstlisting}

\subsection{Function isInternalOwner}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=472]
    function isInternalOwner() private inline view returns (bool) {
        return root_owner_address.value != 0 && root_owner_address == msg.sender;
    }
\end{lstlisting}

\subsection{Function isOwner}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=468]
    function isOwner() private inline view returns (bool) {
        return isInternalOwner() || isExternalOwner();
    }
\end{lstlisting}
