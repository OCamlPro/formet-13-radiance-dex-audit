
\section{Module "DEXClient.sol"}


\subsection{Pragmas}


\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
ton & -solidity \^{}0.45.0 &\\\hline
AbiHeader &  expire &\\\hline
AbiHeader &  pubkey &\\\hline
AbiHeader &  time &\\\hline
\end{tabular}


\subsection{Imports}


\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
./DEXConnector.sol &\\\hline
./interfaces/IRootTokenContract.sol &\\\hline
./interfaces/ITONTokenWallet.sol &\\\hline
./interfaces/ITokensReceivedCallback.sol &\\\hline
./interfaces/IDEXConnector.sol &\\\hline
./interfaces/IDEXConnect.sol &\\\hline
./interfaces/IDEXClient.sol &\\\hline
./interfaces/IDEXPair.sol &\\\hline
./interfaces/IDEXRoot.sol &\\\hline
\end{tabular}


\subsection{Contract DEXClient}


In file {\tt DEXClient.sol}

\subsubsection{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
ITokensReceivedCallback & \\\hline
IDEXClient & \\\hline
IDEXConnect & \\\hline
\end{tabular}


\subsubsection{Type Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Check that types have the correct integer types (Pubkey : uint256, Amount: uint128, Time: uint64 ).
\\\hline\end{tabular}
\fi

\paragraph{Struct Connector}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{6cm}|}\hline
root\_{}address & address & \\\hline
souint & uint256 & \\\hline
status & bool & \\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=29]
  struct Connector {
    address root_address;
    uint256 souint;
    bool status;
  }
\end{lstlisting}

\paragraph{Struct Callback}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{6cm}|}\hline
token\_{}wallet & address & \\\hline
token\_{}root & address & \\\hline
amount & uint128 & \\\hline
sender\_{}public\_{}key & uint256 & \\\hline
sender\_{}address & address & \\\hline
sender\_{}wallet & address & \\\hline
original\_{}gas\_{}to & address & \\\hline
updated\_{}balance & uint128 & \\\hline
payload\_{}arg0 & uint8 & \\\hline
payload\_{}arg1 & address & \\\hline
payload\_{}arg2 & address & \\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=43]
  struct Callback {
    address token_wallet;
    address token_root;
    uint128 amount;
    uint256 sender_public_key;
    address sender_address;
    address sender_wallet;
    address original_gas_to;
    uint128 updated_balance;
    uint8 payload_arg0;
    address payload_arg1;
    address payload_arg2;
  }
\end{lstlisting}

\paragraph{Struct Pair}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{6cm}|}\hline
status & bool & \\\hline
rootA & address & \\\hline
walletA & address & \\\hline
rootB & address & \\\hline
walletB & address & \\\hline
rootAB & address & \\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=60]
  struct Pair {
    bool status;
    address rootA;
    address walletA;
    address rootB;
    address walletB;
    address rootAB;
  }
\end{lstlisting}

\subsubsection{Constant Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Use a naming convention to distinguish constants from other, such as all uppercase names.
\\\hline
Use \verb+ton+ unit instead of nanotons for cost constants to avoid numbers with too many zeroes.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
uint128 & GRAMS\_{}CONNECT\_{}PAIR & Initialized to 500000000  \\\hline
uint128 & GRAMS\_{}SET\_{}CALLBACK\_{}ADDR & Initialized to 100000000  \\\hline
uint128 & GRAMS\_{}SWAP & Initialized to 500000000  \\\hline
uint128 & GRAMS\_{}PROCESS\_{}LIQUIDITY & Initialized to 500000000  \\\hline
uint128 & GRAMS\_{}RETURN\_{}LIQUIDITY & Initialized to 500000000  \\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=23]
  uint128 constant GRAMS_CONNECT_PAIR = 500000000;
\end{lstlisting}

\begin{lstlisting}[firstnumber=24]
  uint128 constant GRAMS_SET_CALLBACK_ADDR = 100000000;
\end{lstlisting}

\begin{lstlisting}[firstnumber=25]
  uint128 constant GRAMS_SWAP = 500000000;
\end{lstlisting}

\begin{lstlisting}[firstnumber=26]
  uint128 constant GRAMS_PROCESS_LIQUIDITY = 500000000;
\end{lstlisting}

\begin{lstlisting}[firstnumber=27]
  uint128 constant GRAMS_RETURN_LIQUIDITY = 500000000;
\end{lstlisting}

\subsubsection{Static Variable Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Use a naming convention to distinguish static variables from global variables, such as \verb+s_+ prefix.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address & rootDEX &  \\\hline
 & & used in @1.DEXClient.createNewPair\\\hline
 & & used in @1.DEXClient.createNewPair\\\hline
 & & used in @1.DEXClient.:constructor\\\hline
uint256 & soUINT &  \\\hline
TvmCell & codeDEXConnector &  \\\hline
 & & used in @1.DEXClient.connectRoot\\\hline
 & & used in @1.DEXClient.computeConnectorAddress\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=18]
  address static public rootDEX;
\end{lstlisting}

\begin{lstlisting}[firstnumber=19]
  uint256 static public soUINT;
\end{lstlisting}

\begin{lstlisting}[firstnumber=20]
  TvmCell static public codeDEXConnector;
\end{lstlisting}

\subsubsection{Variable Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Use a naming convention to distinguish global variables from local variables, such as \verb+g_+ or \verb+m_+ prefix.
\\\hline\end{tabular}
\fi

\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address [] & rootKeys &  \\\hline
 & & used in @1.DEXClient.getAllDataPreparation\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
mapping (address =$>$ address) & rootWallet &  \\\hline
 & & used in @1.DEXClient.sendTokens\\\hline
 & & used in @1.DEXClient.returnLiquidity\\\hline
 & & used in @1.DEXClient.returnLiquidity\\\hline
 & & used in @1.DEXClient.processSwapB\\\hline
 & & used in @1.DEXClient.processSwapA\\\hline
 & & used in @1.DEXClient.processLiquidity\\\hline
 & & used in @1.DEXClient.processLiquidity\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.connectRoot\\\hline
 & & assigned in @1.DEXClient.connectCallback\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
mapping (address =$>$ address) & rootConnector &  \\\hline
 & & used in @1.DEXClient.sendTokens\\\hline
 & & used in @1.DEXClient.sendTokens\\\hline
 & & used in @1.DEXClient.returnLiquidity\\\hline
 & & used in @1.DEXClient.returnLiquidity\\\hline
 & & used in @1.DEXClient.processSwapB\\\hline
 & & used in @1.DEXClient.processSwapA\\\hline
 & & used in @1.DEXClient.processLiquidity\\\hline
 & & used in @1.DEXClient.processLiquidity\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & assigned in @1.DEXClient.connectCallback\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
mapping (address =$>$ Connector) & connectors &  \\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & assigned in @1.DEXClient.connectRoot\\\hline
 & & used in @1.DEXClient.connectRoot\\\hline
 & & used in @1.DEXClient.connectRoot\\\hline
 & & assigned in @1.DEXClient.connectCallback\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
 & & used in @1.DEXClient.connectCallback\\\hline
uint256 & counterCallback &  \\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & assigned in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & assigned in @1.DEXClient.:constructor\\\hline
 & & used in @1.DEXClient.:constructor\\\hline
mapping (uint256 =$>$ Callback) & callbacks &  \\\hline
 & & assigned in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & assigned in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.tokensReceivedCallback\\\hline
 & & used in @1.DEXClient.getFirstCallback\\\hline
 & & used in @1.DEXClient.getCallback\\\hline
mapping (address =$>$ Pair) & pairs &  \\\hline
 & & assigned in @1.DEXClient.setPair\\\hline
 & & used in @1.DEXClient.setPair\\\hline
 & & used in @1.DEXClient.setPair\\\hline
 & & used in @1.DEXClient.setPair\\\hline
 & & used in @1.DEXClient.returnLiquidity\\\hline
 & & used in @1.DEXClient.processSwapB\\\hline
 & & used in @1.DEXClient.processSwapA\\\hline
 & & used in @1.DEXClient.processLiquidity\\\hline
 & & used in @1.DEXClient.isReadyToProvide\\\hline
 & & used in @1.DEXClient.isReady\\\hline
 & & used in @1.DEXClient.getPairData\\\hline
 & & assigned in @1.DEXClient.connectPair\\\hline
 & & used in @1.DEXClient.connectPair\\\hline
 & & used in @1.DEXClient.connectPair\\\hline
 & & used in @1.DEXClient.connectPair\\\hline
address [] & pairKeys &  \\\hline
 & & used in @1.DEXClient.getAllDataPreparation\\\hline
 & & used in @1.DEXClient.connectPair\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=35]
  address[] public rootKeys;
\end{lstlisting}

\begin{lstlisting}[firstnumber=36]
  mapping (address => address) public rootWallet;
\end{lstlisting}

\begin{lstlisting}[firstnumber=37]
  mapping (address => address) public rootConnector;
\end{lstlisting}

\begin{lstlisting}[firstnumber=38]
  mapping (address => Connector) connectors;
\end{lstlisting}

\begin{lstlisting}[firstnumber=40]
  uint public counterCallback;
\end{lstlisting}

\begin{lstlisting}[firstnumber=57]
  mapping (uint => Callback) callbacks;
\end{lstlisting}

\begin{lstlisting}[firstnumber=69]
  mapping(address => Pair) public pairs;
\end{lstlisting}

\begin{lstlisting}[firstnumber=70]
  address[] public pairKeys;
\end{lstlisting}

\subsubsection{Modifier Definitions}


\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Calling tvm.accept() without checking pubkey should not be allowed
\\\hline\end{tabular}
\fi

\paragraph{Modifier alwaysAccept}


\begin{lstlisting}[firstnumber=73]
  modifier alwaysAccept {
    tvm.accept();
    _;
  }
\end{lstlisting}

\paragraph{Modifier checkOwnerAndAccept}


\begin{lstlisting}[firstnumber=79]
  modifier checkOwnerAndAccept {
    require(msg.pubkey() == tvm.pubkey(), 102);
    tvm.accept();
    _;
  }
\end{lstlisting}

\subsubsection{Constructor Definitions}


\paragraph{Constructor}

\issueCritical{Constructor for DEXClient}{loren ipsum  loren ipsum  loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum

loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum
loren ipsum loren ipsum loren ipsum }

\ifsoldraft
\noindent\begin{tabular}{|p{12cm}|}\hline
\rowcolor{green}Advises
\\\hline
Check who can call the constructor. If the constructor sets global values, only legitimate users should be allowed.
\\\hline
Check that every argument is protected by a require().
\\\hline
If external users are allowed, their pubkey should be verified (\verb+require(msg.pubkey() != 0 && msg.pubkey() == tvm.pubkey(),100)+ , and tvm.accept() should be called.
\\\hline\end{tabular}
\fi
\vspace{2cm}

\begin{lstlisting}[firstnumber=85]
  constructor() public {
    require(msg.sender == rootDEX, 103);
    tvm.accept();
    counterCallback = 0;
  }
\end{lstlisting}

\subsubsection{Public Method Definitions}


\paragraph{Function connectCallback}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt wallet &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt alwaysAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=181]
  function connectCallback(address wallet) public override alwaysAccept {
    address connector = msg.sender;
    if (connectors.exists(connector)) {
      Connector cc = connectors[connector];
      rootKeys.push(cc.root_address);
      rootWallet[cc.root_address] = wallet;
      rootConnector[cc.root_address] = connector;
      TvmCell bodySTC = tvm.encodeBody(IDEXConnector(connector).setTransferCallback);
      connector.transfer({value: GRAMS_SET_CALLBACK_ADDR, bounce:true, flag: 0, body:bodySTC});
      TvmCell bodySBC = tvm.encodeBody(IDEXConnector(connector).setBouncedCallback);
      connector.transfer({value: GRAMS_SET_CALLBACK_ADDR, bounce:true, flag: 0, body:bodySBC});
      cc.status = true;
      connectors[connector] = cc;
    }
  }
\end{lstlisting}

\paragraph{Function connectPair}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt statusConnection &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=92]
  function connectPair(address pairAddr) public checkOwnerAndAccept  returns (bool statusConnection) {
    statusConnection = false;
    if (!pairs.exists(pairAddr)){
      Pair cp = pairs[pairAddr];
      cp.status = false;
      pairs[pairAddr] = cp;
      pairKeys.push(pairAddr);
      TvmCell body = tvm.encodeBody(IDEXPair(pairAddr).connect);
      pairAddr.transfer({value:GRAMS_CONNECT_PAIR, body:body});
      statusConnection = true;
    }
  }
\end{lstlisting}

\paragraph{Function connectRoot}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt root &\\\hline
\tt uint256 & \tt souint &\\\hline
\tt uint128 & \tt gramsToConnector &\\\hline
\tt uint128 & \tt gramsToRoot &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt statusConnected &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=158]
  function connectRoot(address root, uint256 souint, uint128 gramsToConnector, uint128 gramsToRoot) public checkOwnerAndAccept returns (bool statusConnected){
    statusConnected = false;
    if (!rootWallet.exists(root)) {
      TvmCell stateInit = tvm.buildStateInit({
        contr: DEXConnector,
        varInit: { soUINT: souint, dexclient: address(this) },
        code: codeDEXConnector,
        pubkey: tvm.pubkey()
      });
      TvmCell init = tvm.encodeBody(DEXConnector);
      address connector = tvm.deploy(stateInit, init, gramsToConnector, address(this).wid);
      Connector cr = connectors[connector];
      cr.root_address = root;
      cr.souint = souint;
      cr.status = false;
      connectors[connector] = cr;
      TvmCell body = tvm.encodeBody(IDEXConnector(connector).deployEmptyWallet, root);
      connector.transfer({value:gramsToRoot, bounce:true, body:body});
      statusConnected = true;
    }
  }
\end{lstlisting}

\paragraph{Function createNewPair}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt root0 &\\\hline
\tt address & \tt root1 &\\\hline
\tt uint256 & \tt pairSoArg &\\\hline
\tt uint256 & \tt connectorSoArg0 &\\\hline
\tt uint256 & \tt connectorSoArg1 &\\\hline
\tt uint256 & \tt rootSoArg &\\\hline
\tt bytes & \tt rootName &\\\hline
\tt bytes & \tt rootSymbol &\\\hline
\tt uint8 & \tt rootDecimals &\\\hline
\tt uint128 & \tt grammsForPair &\\\hline
\tt uint128 & \tt grammsForRoot &\\\hline
\tt uint128 & \tt grammsForConnector &\\\hline
\tt uint128 & \tt grammsForWallet &\\\hline
\tt uint128 & \tt grammsTotal &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=356]
  function createNewPair(
    address root0,
		address root1,
		uint256 pairSoArg,
		uint256 connectorSoArg0,
		uint256 connectorSoArg1,
		uint256 rootSoArg,
		bytes rootName,
		bytes rootSymbol,
		uint8 rootDecimals,
		uint128 grammsForPair,
		uint128 grammsForRoot,
		uint128 grammsForConnector,
		uint128 grammsForWallet,
    uint128 grammsTotal
  ) public view checkOwnerAndAccept  {
    require (!(grammsTotal < (grammsForPair+2*grammsForConnector+2*grammsForWallet+grammsForRoot)) && !(grammsTotal < 5 ton),106);
    require (!(address(this).balance < grammsTotal),105);
    TvmCell body = tvm.encodeBody(IDEXRoot(rootDEX).createDEXpair, root0,root1,pairSoArg,connectorSoArg0,connectorSoArg1,rootSoArg,rootName,rootSymbol,rootDecimals,grammsForPair,grammsForRoot,grammsForConnector,grammsForWallet);
    rootDEX.transfer({value:grammsTotal, bounce:false, flag: 1, body:body});
  }
\end{lstlisting}

\paragraph{Function getAllDataPreparation}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address [] & \tt pairKeysR &\\\hline
\tt address [] & \tt rootKeysR &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt alwaysAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=215]
  function getAllDataPreparation() public view alwaysAccept returns(address[] pairKeysR, address[] rootKeysR){
    pairKeysR = pairKeys;
    rootKeysR = rootKeys;
  }
\end{lstlisting}

\paragraph{Function getBalance}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint128 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=351]
  function getBalance() public pure responsible returns (uint128) {
    return { value: 0, bounce: false, flag: 64 } thisBalance();
  }
\end{lstlisting}

\paragraph{Function getCallback}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt id &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & \tt token\_{}wallet &\\\hline
\tt address & \tt token\_{}root &\\\hline
\tt uint128 & \tt amount &\\\hline
\tt uint256 & \tt sender\_{}public\_{}key &\\\hline
\tt address & \tt sender\_{}address &\\\hline
\tt address & \tt sender\_{}wallet &\\\hline
\tt address & \tt original\_{}gas\_{}to &\\\hline
\tt uint128 & \tt updated\_{}balance &\\\hline
\tt uint8 & \tt payload\_{}arg0 &\\\hline
\tt address & \tt payload\_{}arg1 &\\\hline
\tt address & \tt payload\_{}arg2 &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=318]
  function getCallback(uint id) public view checkOwnerAndAccept returns (
    address token_wallet,
    address token_root,
    uint128 amount,
    uint256 sender_public_key,
    address sender_address,
    address sender_wallet,
    address original_gas_to,
    uint128 updated_balance,
    uint8 payload_arg0,
    address payload_arg1,
    address payload_arg2
  ){
    Callback cc = callbacks[id];
    token_wallet = cc.token_wallet;
    token_root = cc.token_root;
    amount = cc.amount;
    sender_public_key = cc.sender_public_key;
    sender_address = cc.sender_address;
    sender_wallet = cc.sender_wallet;
    original_gas_to = cc.original_gas_to;
    updated_balance = cc.updated_balance;
    payload_arg0 = cc.payload_arg0;
    payload_arg1 = cc.payload_arg1;
    payload_arg2 = cc.payload_arg2;
  }
\end{lstlisting}

\paragraph{Function getConnectorAddress}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt connectorSoArg &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=153]
  function getConnectorAddress(uint256 connectorSoArg) public view responsible returns (address) {
    return { value: 0, bounce: false, flag: 64 } computeConnectorAddress( connectorSoArg);
  }
\end{lstlisting}

\paragraph{Function getPairData}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt pairStatus &\\\hline
\tt address & \tt pairRootA &\\\hline
\tt address & \tt pairWalletA &\\\hline
\tt address & \tt pairRootB &\\\hline
\tt address & \tt pairWalletB &\\\hline
\tt address & \tt pairRootAB &\\\hline
\tt address & \tt curPair &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt alwaysAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=379]
  function getPairData(address pairAddr) public view alwaysAccept returns (
    bool pairStatus,
    address pairRootA,
    address pairWalletA,
    address pairRootB,
    address pairWalletB,
    address pairRootAB,
    address curPair
  ){
    Pair cp = pairs[pairAddr];
    pairStatus = cp.status;
    pairRootA = cp.rootA;
    pairWalletA = cp.walletA;
    pairRootB = cp.rootB;
    pairWalletB = cp.walletB;
    pairRootAB = cp.rootAB;
    curPair = pairAddr;
  }
\end{lstlisting}

\paragraph{Function processLiquidity}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\tt uint128 & \tt qtyA &\\\hline
\tt uint128 & \tt qtyB &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt processLiquidityStatus &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=251]
  function processLiquidity(address pairAddr, uint128 qtyA, uint128 qtyB) public view checkOwnerAndAccept returns (bool processLiquidityStatus) {
    processLiquidityStatus = false;
    if (isReadyToProvide(pairAddr)) {
      Pair cp = pairs[pairAddr];
      address connectorA = rootConnector[cp.rootA];
      address connectorB = rootConnector[cp.rootB];
      TvmBuilder builderA;
      builderA.store(uint8(2), address(this), rootWallet[cp.rootAB]);
      TvmCell payloadA = builderA.toCell();
      TvmBuilder builderB;
      builderB.store(uint8(2), address(this), rootWallet[cp.rootAB]);
      TvmCell payloadB = builderB.toCell();
      TvmCell bodyA = tvm.encodeBody(IDEXConnector(connectorA).transfer, cp.walletA, qtyA, payloadA);
      TvmCell bodyB = tvm.encodeBody(IDEXConnector(connectorB).transfer, cp.walletB, qtyB, payloadB);
      connectorA.transfer({value: GRAMS_PROCESS_LIQUIDITY, bounce:true, body:bodyA});
      connectorB.transfer({value: GRAMS_PROCESS_LIQUIDITY, bounce:true, body:bodyB});
      processLiquidityStatus = true;
    }
  }
\end{lstlisting}

\paragraph{Function processSwapA}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\tt uint128 & \tt qtyA &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt processSwapStatus &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=221]
  function processSwapA(address pairAddr, uint128 qtyA) public view checkOwnerAndAccept returns (bool processSwapStatus) {
    processSwapStatus = false;
    if (isReady(pairAddr)) {
      Pair cp = pairs[pairAddr];
      address connector = rootConnector[cp.rootA];
      TvmBuilder builder;
      builder.store(uint8(1), cp.rootB, rootWallet[cp.rootB]);
      TvmCell payload = builder.toCell();
      TvmCell body = tvm.encodeBody(IDEXConnector(connector).transfer, cp.walletA, qtyA, payload);
      connector.transfer({value: GRAMS_SWAP, bounce:true, body:body});
      processSwapStatus = true;
    }
  }
\end{lstlisting}

\paragraph{Function processSwapB}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\tt uint128 & \tt qtyB &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt processSwapStatus &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=236]
  function processSwapB(address pairAddr, uint128 qtyB) public view checkOwnerAndAccept returns (bool processSwapStatus) {
    processSwapStatus = false;
    if (isReady(pairAddr)) {
      Pair cp = pairs[pairAddr];
      address connector = rootConnector[cp.rootB];
      TvmBuilder builder;
      builder.store(uint8(1), cp.rootA, rootWallet[cp.rootA]);
      TvmCell payload = builder.toCell();
      TvmCell body = tvm.encodeBody(IDEXConnector(connector).transfer, cp.walletB, qtyB, payload);
      connector.transfer({value: GRAMS_SWAP, bounce:true, body:body});
      processSwapStatus = true;
    }
  }
\end{lstlisting}

\paragraph{Function returnLiquidity}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pairAddr &\\\hline
\tt uint128 & \tt tokens &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt returnLiquidityStatus &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=272]
  function returnLiquidity(address pairAddr, uint128 tokens) public view checkOwnerAndAccept returns (bool returnLiquidityStatus) {
    returnLiquidityStatus = false;
    if (isReadyToProvide(pairAddr)) {
    Pair cp = pairs[pairAddr];
    TvmBuilder builder;
    builder.store(uint8(3), rootWallet[cp.rootA], rootWallet[cp.rootB]);
    TvmCell callback_payload = builder.toCell();
    TvmCell body = tvm.encodeBody(IDEXConnector(rootConnector[cp.rootAB]).burn, tokens, pairAddr, callback_payload);
    rootConnector[cp.rootAB].transfer({value:GRAMS_RETURN_LIQUIDITY, body:body});
    returnLiquidityStatus = true;
    }
  }
\end{lstlisting}

\paragraph{Function sendTokens}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt tokenRoot &\\\hline
\tt address & \tt to &\\\hline
\tt uint128 & \tt tokens &\\\hline
\tt uint128 & \tt grams &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & \tt sendTokenStatus &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt checkOwnerAndAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=399]
  function sendTokens(address tokenRoot, address to, uint128 tokens, uint128 grams) public checkOwnerAndAccept view returns (bool sendTokenStatus){
    sendTokenStatus = false;
    if (rootConnector[tokenRoot] != address(0)) {
      address connector = rootConnector[tokenRoot];
      TvmBuilder builder;
      builder.store(uint8(4), address(this), rootWallet[tokenRoot]);
      TvmCell payload = builder.toCell();
      TvmCell body = tvm.encodeBody(IDEXConnector(connector).transfer, to, tokens, payload);
      connector.transfer({value: grams, bounce:true, body:body});
      sendTokenStatus = true;
    }
  }
\end{lstlisting}

\paragraph{Function setPair}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt arg0 &\\\hline
\tt address & \tt arg1 &\\\hline
\tt address & \tt arg2 &\\\hline
\tt address & \tt arg3 &\\\hline
\tt address & \tt arg4 &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt alwaysAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=127]
  function setPair(address arg0, address arg1, address arg2, address arg3, address arg4) public alwaysAccept override {
    address dexpair = msg.sender;
    if (pairs.exists(dexpair)){
      Pair cp = pairs[dexpair];
      cp.status = true;
      cp.rootA = arg0;
      cp.walletA = arg1;
      cp.rootB = arg2;
      cp.walletB = arg3;
      cp.rootAB = arg4;
      pairs[dexpair] = cp;
    }
  }
\end{lstlisting}

\paragraph{Function tokensReceivedCallback}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt token\_{}wallet &\\\hline
\tt address & \tt token\_{}root &\\\hline
\tt uint128 & \tt amount &\\\hline
\tt uint256 & \tt sender\_{}public\_{}key &\\\hline
\tt address & \tt sender\_{}address &\\\hline
\tt address & \tt sender\_{}wallet &\\\hline
\tt address & \tt original\_{}gas\_{}to &\\\hline
\tt uint128 & \tt updated\_{}balance &\\\hline
\tt TvmCell & \tt payload &\\\hline
\multicolumn{3}{|l|}{\bf Modifiers}\\\hline
\tt alwaysAccept & {\em no args} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=286]
  function tokensReceivedCallback(
    address token_wallet,
    address token_root,
    uint128 amount,
    uint256 sender_public_key,
    address sender_address,
    address sender_wallet,
    address original_gas_to,
    uint128 updated_balance,
    TvmCell payload
  ) public override alwaysAccept {
    Callback cc = callbacks[counterCallback];
    cc.token_wallet = token_wallet;
    cc.token_root = token_root;
    cc.amount = amount;
    cc.sender_public_key = sender_public_key;
    cc.sender_address = sender_address;
    cc.sender_wallet = sender_wallet;
    cc.original_gas_to = original_gas_to;
    cc.updated_balance = updated_balance;
    TvmSlice slice = payload.toSlice();
    (uint8 arg0, address arg1, address arg2) = slice.decode(uint8, address, address);
    cc.payload_arg0 = arg0;
    cc.payload_arg1 = arg1;
    cc.payload_arg2 = arg2;
    callbacks[counterCallback] = cc;
    counterCallback++;
    if (counterCallback > 10){delete callbacks[getFirstCallback()];}
  }
\end{lstlisting}

\subsubsection{Internal Method Definitions}


\paragraph{Receive function}

\vspace{2cm}

\begin{lstlisting}[firstnumber=413]
  receive() external {
  }
\end{lstlisting}

\paragraph{Function computeConnectorAddress}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint256 & \tt souint &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt address & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=142]
  function computeConnectorAddress(uint256 souint) private inline view returns (address) {
    TvmCell stateInit = tvm.buildStateInit({
      contr: DEXConnector,
      varInit: { soUINT: souint, dexclient: address(this) },
      code: codeDEXConnector,
      pubkey: tvm.pubkey()
    });
    return address(tvm.hash(stateInit));
  }
\end{lstlisting}

\paragraph{Function getFirstCallback}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint256 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=121]
  function getFirstCallback() private view returns (uint) {
		optional(uint, Callback) rc = callbacks.min();
		if (rc.hasValue()) {(uint number, ) = rc.get();return number;} else {return 0;}
	}
\end{lstlisting}

\paragraph{Function getQuotient}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt arg0 &\\\hline
\tt uint128 & \tt arg1 &\\\hline
\tt uint128 & \tt arg2 &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint128 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=109]
  function getQuotient(uint128 arg0, uint128 arg1, uint128 arg2) private inline pure returns (uint128) {
    (uint128 quotient, ) = math.muldivmod(arg0, arg1, arg2);
    return quotient;
  }
\end{lstlisting}

\paragraph{Function getRemainder}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt uint128 & \tt arg0 &\\\hline
\tt uint128 & \tt arg1 &\\\hline
\tt uint128 & \tt arg2 &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint128 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=115]
  function getRemainder(uint128 arg0, uint128 arg1, uint128 arg2) private inline pure returns (uint128) {
    (, uint128 remainder) = math.muldivmod(arg0, arg1, arg2);
    return remainder;
  }
\end{lstlisting}

\paragraph{Function isReady}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pair &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=198]
  function isReady(address pair) private inline view returns (bool) {
    Pair cp = pairs[pair];
    Connector ccA = connectors[rootConnector[cp.rootA]];
    Connector ccB = connectors[rootConnector[cp.rootB]];
    return cp.status && rootWallet.exists(cp.rootA) && rootWallet.exists(cp.rootB) && rootConnector.exists(cp.rootA) && rootConnector.exists(cp.rootB) && ccA.status && ccB.status;
  }
\end{lstlisting}

\paragraph{Function isReadyToProvide}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Parameters}\\\hline
\tt address & \tt pair &\\\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt bool & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=206]
  function isReadyToProvide(address pair) private inline view returns (bool) {
    Pair cp = pairs[pair];
    Connector ccA = connectors[rootConnector[cp.rootA]];
    Connector ccB = connectors[rootConnector[cp.rootB]];
    return cp.status && rootWallet.exists(cp.rootA) && rootWallet.exists(cp.rootB) && rootWallet.exists(cp.rootAB) && rootConnector.exists(cp.rootA) && rootConnector.exists(cp.rootB) && ccA.status && ccB.status;
  }
\end{lstlisting}

\paragraph{Function thisBalance}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
\multicolumn{3}{|l|}{\bf Returns}\\\hline
\tt uint128 & {\em no name} &\\\hline
\end{tabular}
\fi

\vspace{2cm}

\begin{lstlisting}[firstnumber=346]
  function thisBalance() private inline  pure returns (uint128) {
    return address(this).balance;
  }
\end{lstlisting}
